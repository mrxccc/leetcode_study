**首先是对题意的理解：即寻找最多包含两种水果类型的最长连续子串长度。**

i为当前遍历节点。

水果1为前一棵果树水果类型，水果2为采摘的另一种水果类型。

dp[0]表示当前水果种类最大连续长度

dp[1]表示最多包含2种水果的最大连续最大长度

a代表水果2的种类。

一共分为三种情况：

(1) 当fruit[i]与当前两种水果都不同时，即fruit[i] != fruit[i - 1] && fruit[i] != a，**（因为要求连续，所以遇到第三种水果3，就把水果2类型更新为前一棵树的水果类型，水果3成为新的水果1)**

则有：

res = max(dp[1], res); //更新最大数目

a = fruits[i - 1]; //将前一棵果树的果子作为水果2

dp[1] = dp[0] + 1; //前一棵树水果类型的连续数量+当前树的1个水果

dp[0] = 1; //更新当前水果类型的连续长度

(2) 当当前果树与上一棵果树水果类型相同时，即fruit[i] == fruit[i - 1]

则有：

dp[0]++; //当前水果类型连续长度+1

dp[1]++; //总连续长度+1

(3) 当当前果树水果与水果2类型相同时，即fruit[i] == a

则有：

a = fruits[i - 1]; //将前一棵果树的果子作为水果2

dp[0] = 1; //更新当前水果类型的连续长度

dp[1]++; //总连续长度+1

最后，返回结果max(res, dp[1])。

代码如下：

* 

```
public int totalFruit(int[] fruits) {
    int n = fruits.length;
    int[] dp = new int[2]; 
    int res = 0;
    int a = -1; //除前一棵果树的水果外，采摘的另一种水果
    dp[0] = 1;dp[1] = 1;
    for(int i = 1; i < n; i++){
        if(fruits[i] != fruits[i - 1] && fruits[i] != a){ //与当前采摘的两种水果都不同
            if(dp[1] > res) res = dp[1]; //更新连续最大数目
            a = fruits[i - 1]; //将前一棵果树的果子作为水果2
            dp[1] = dp[0] + 1; //前一棵树水果类型连续数量+当前树的1个水果
            dp[0] = 1; //更新当前水果类型的连续长度
        }else if(fruits[i] == fruits[i - 1]){ //与前一棵树种类相同
            dp[0]++; //当前水果类型连续长度+1
            dp[1]++; //总连续长度+1
        }else if(fruits[i] == a){ //与水果2类型相同
            a = fruits[i - 1]; //将前一棵果树的果子作为新的水果2
            dp[0] = 1; //更新当前水果种类连续长度
            dp[1]++; //更新总连续长度
        }
    }
    return Math.max(res, dp[1]);
}
```

复杂度为O(N) + O(1)

提交结果：

![image.png](https://pic.leetcode-cn.com/1665970162-NVjUCD-image.png)

